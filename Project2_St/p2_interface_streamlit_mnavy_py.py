# -*- coding: utf-8 -*-
"""P2 - INTERFACE STREAMLIT - MNAVY.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1knLplfiNz22PpXsCO_BRQSWbUFECMs_U

## Bibliothèque
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import StandardScaler
from difflib import get_close_matches
from sklearn.neighbors import NearestNeighbors

"""## Importation des données"""

df_movies_full = pd.read_csv('https://drive.google.com/uc?export=download&id=1NM-8BsunxFQLqI7jvoP1Va6afWBPS7CT', low_memory=True)
display(df_movies_full.head(3))

df_movies_full.info()

df_series_full = pd.read_csv('https://drive.google.com/uc?export=download&id=1KEHdOqFsRklP24h51L1gBEL28O4U2qUa', low_memory=True)
display(df_series_full.head(3))

df_series_full.info()

"""## FILMS - ML"""

# Sélectionner uniquement les colonnes numériques
numeric_features = df_movies_full.select_dtypes(include=['number']).columns
X = df_movies_full[numeric_features]

# Normaliser les colonnes numériques
scaler = StandardScaler()
X_scaled = pd.DataFrame(scaler.fit_transform(X), columns=numeric_features)

# Créer le modèle KNN en utilisant les données normalisées
knn = NearestNeighbors(n_neighbors=10, algorithm='auto').fit(X_scaled)

# Fonction de recommandation avec correspondance approximative
def recommend_movies(movie_title, df, X, model, n_recommendations):
    # Vérifier si le film existe dans le DataFrame (insensible à la casse)
    movie_title_lower = movie_title.lower()
    matches = df['primaryTitle'].str.lower() == movie_title_lower
    if not matches.any():
        close_matches = get_close_matches(movie_title, df['primaryTitle'].values, n=1, cutoff=0.8)
        if not close_matches:
            print(f"Le film '{movie_title}' n'existe pas dans le dataset.")
            return []  # Retourner une liste vide ou un message d'erreur
        else:
            movie_title = close_matches[0]
            print(f"Film non trouvé. Utilisation de la correspondance la plus proche : {movie_title}")
    else:
        movie_title = df[matches]['primaryTitle'].values[0]

    # Trouver l'indice du film dans le DataFrame
    movie_idx = df[df['primaryTitle'] == movie_title].index[0]

    # Trouver les voisins les plus proches
    distances, indices = model.kneighbors(X.iloc[movie_idx, :].values.reshape(1, -1), n_neighbors=n_recommendations+1)

    # Obtenir les indices des films recommandés, en excluant le film de référence
    rec_movie_indices = indices.flatten()[1:]

    return df.iloc[rec_movie_indices]['primaryTitle'].tolist()

movie_title = input("Entrez le titre du film pour obtenir des recommandations : ").strip()
recommended_movies = recommend_movies(movie_title, df_movies_full, X_scaled, knn, 5)
if recommended_movies:
    print("Films recommandés :")
    for title in recommended_movies:
        print(title)
else:
    print("Aucune recommandation trouvée.")

# Pour afficher les images il faut utiliser : "https://image.tmdb.org/t/p/w500" + poster_path
def get_poster_path(movie_id):
    poster_path = df_movies_full[df_movies_full['tconst'] == movie_id]['poster_path'].values[0]
    full_path = "https://image.tmdb.org/t/p/w500/" + poster_path
    return full_path

# Afficher les details d'un film
def display_details(movie_id):
    movie = df_movies_full[df_movies_full['tconst'] == movie_id]
    if not movie.empty:
        row = movie.iloc[0]

        # Récupérer les genres à partir des colonnes one-hot encoded
        genre_columns = [col for col in df_movies_full.columns if col.startswith('genres_')]
        genres = [col.split('_')[1] for col in genre_columns if row[col] == 1]

        # Convertir runtimeMinutes en heures et minutes
        runtime_minutes = row['runtimeMinutes']
        hours = runtime_minutes // 60
        minutes = runtime_minutes % 60
        runtime_formatted = f"{hours}h{minutes}" if hours > 0 else f"{minutes}m"

        # Afficher les détails
        print(get_poster_path(row['tconst']))
        print(f"**{row['primaryTitle']}** ({runtime_formatted})")
        print(f"**Année de sortie:** {row['startYear']}")
        print(f"**Genres:** {', '.join(genres)}")
        print(f"**Rating:** {row['averageRating']}/10")
        print(f"**Overview:** {row['overview']}")
        print("---")

display_details('tt0475659')

"""## SERIES - ML"""

# Sélectionner uniquement les colonnes numériques
numeric_features_series = df_series_full.select_dtypes(include=['number']).columns
X_series = df_series_full[numeric_features_series]

# Normaliser les colonnes numériques
scaler_series = StandardScaler()
X_series_scaled = pd.DataFrame(scaler_series.fit_transform(X_series), columns=numeric_features_series)

# Créer le modèle KNN en utilisant les données normalisées
knn_series = NearestNeighbors(n_neighbors=10, algorithm='auto').fit(X_series_scaled)

# Fonction de recommandation avec correspondance approximative
def recommend_series(serie_title, df, X, model, n_recommendations):
    # Vérifier si la série existe dans le DataFrame (insensible à la casse)
    serie_title_lower = serie_title.lower()
    matches = df['primaryTitle'].str.lower() == serie_title_lower
    if not matches.any():
        close_matches = get_close_matches(serie_title, df['primaryTitle'].values, n=1, cutoff=0.8)
        if not close_matches:
            print(f"La série '{serie_title}' n'existe pas dans le dataset.")
            return []  # Retourner une liste vide ou un message d'erreur
        else:
            serie_title = close_matches[0]
            print(f"Série non trouvée. Utilisation de la correspondance la plus proche : {serie_title}")
    else:
        serie_title = df[matches]['primaryTitle'].values[0]

    # Trouver l'indice de la série dans le DataFrame
    serie_idx = df[df['primaryTitle'] == serie_title].index[0]

    # Trouver les voisins les plus proches
    distances, indices = model.kneighbors(X.iloc[serie_idx, :].values.reshape(1, -1), n_neighbors=n_recommendations+1)

    # Obtenir les indices des séries recommandées, en excluant la série de référence
    rec_serie_indices = indices.flatten()[1:]

    return df.iloc[rec_serie_indices]['primaryTitle'].tolist()

serie_title = input("Entrez le titre de la série pour obtenir des recommandations : ").strip()
recommended_series = recommend_series(serie_title, df_series_full, X_series_scaled, knn_series, 5)
if recommended_series:
    print("Séries recommandées :")
    for title in recommended_series:
        print(title)
else:
    print("Aucune recommandation trouvée.")

def get_poster_path(serie_id):
    poster_path = df_series_full[df_series_full['tconst'] == serie_id]['poster_path'].values[0]
    full_path = "https://image.tmdb.org/t/p/w500/" + poster_path
    return full_path

def display_details_series(serie_id):
    serie = df_series_full[df_series_full['tconst'] == serie_id]
    if not serie.empty:
        row = serie.iloc[0]

        # Récupérer les genres à partir des colonnes one-hot encoded
        genre_columns = [col for col in df_series_full.columns if col.startswith('genres_')]
        genres = [col.split('_')[1] for col in genre_columns if row[col] == 1]

        # Convertir runtimeMinutes en heures et minutes
        runtime_minutes = row['runtimeMinutes']
        hours = runtime_minutes // 60
        minutes = runtime_minutes % 60
        runtime_formatted = f"{hours}h{minutes}" if hours > 0 else f"{minutes}m"

        # Récupérer le nombre de saisons et d'épisodes s'il s'agit d'une série
        series_info = df_series_full[df_series_full['tconst'] == serie_id]
        if not series_info.empty:
            total_seasons = series_info['seasonNumber'].max()
            total_episodes = series_info['episodeNumber'].max()
        else:
            total_seasons = "N/A"
            total_episodes = "N/A"

        # Afficher les détails
        print(get_poster_path(row['tconst']))
        print(f"**{row['primaryTitle']}** ({runtime_formatted})")
        print(f"**Année :** {row['startYear']}")
        print(f"**Genres :** {', '.join(genres)}")
        print(f"**Note :** {row['averageRating']}/10")
        print(f"**Résumé :** {row['overview']}")
        if total_seasons != "N/A" and total_episodes != "N/A":
            print(f"**Saison :** {total_seasons}")
            print(f"**Episode :** {total_episodes}")
        print("---")

display_details_series('tt0200656')

"""## INTERFACE STREAMLIT"""

# import requests
# import shutil

# url = 'https://drive.google.com/uc?export=view&id=1XB8_os6GbGsLTsopuxOESktuvTLicE99'
# response = requests.get(url, stream=True)

# if response.status_code == 200:
#     with open('./header.png', 'wb') as out_file:
#         shutil.copyfileobj(response.raw, out_file)
#     print('Image téléchargée avec succès.')
# else:
#     print('Échec du téléchargement de l\'image.')

# pip install streamlit

import streamlit as st

# Normalisation des colonnes numériques
def normalize_data(df):
    numeric_features = df.select_dtypes(include=['number']).columns
    X = df[numeric_features]
    scaler = StandardScaler()
    X_scaled = pd.DataFrame(scaler.fit_transform(X), columns=numeric_features)
    return X_scaled

X_movies_scaled = normalize_data(df_movies_full)
X_series_scaled = normalize_data(df_series_full)

# Créer les modèles KNN
knn_movies = NearestNeighbors(n_neighbors=10, algorithm='auto').fit(X_movies_scaled)
knn_series = NearestNeighbors(n_neighbors=10, algorithm='auto').fit(X_series_scaled)

# Fonction de recommandation de films
def recommend_movies(movie_title, df, X, model, n_recommendations):
    movie_title_lower = movie_title.lower()
    matches = df['primaryTitle'].str.lower() == movie_title_lower
    if not matches.any():
        close_matches = get_close_matches(movie_title, df['primaryTitle'].values, n=1, cutoff=0.8)
        if not close_matches:
            return None, []
        else:
            movie_title = close_matches[0]
    else:
        movie_title = df[matches]['primaryTitle'].values[0]

    movie_idx = df[df['primaryTitle'] == movie_title].index[0]
    distances, indices = model.kneighbors(X.iloc[movie_idx, :].values.reshape(1, -1), n_neighbors=n_recommendations+1)
    rec_movie_indices = indices.flatten()[1:]

    return movie_title, df.iloc[rec_movie_indices]['tconst'].tolist()

# Fonction de recommandation de séries
def recommend_series(serie_title, df, X, model, n_recommendations):
    serie_title_lower = serie_title.lower()
    matches = df['primaryTitle'].str.lower() == serie_title_lower
    if not matches.any():
        close_matches = get_close_matches(serie_title, df['primaryTitle'].values, n=1, cutoff=0.8)
        if not close_matches:
            return None, []
        else:
            serie_title = close_matches[0]
    else:
        serie_title = df[matches]['primaryTitle'].values[0]

    serie_idx = df[df['primaryTitle'] == serie_title].index[0]
    distances, indices = model.kneighbors(X.iloc[serie_idx, :].values.reshape(1, -1), n_neighbors=n_recommendations+1)
    rec_serie_indices = indices.flatten()[1:]

    return serie_title, df.iloc[rec_serie_indices]['tconst'].tolist()

# Pour afficher les images
def get_poster_path(df, item_id):
    poster_path = df[df['tconst'] == item_id]['poster_path'].values[0]
    full_path = "https://image.tmdb.org/t/p/w500/" + poster_path
    return full_path

# Afficher les détails d'un film
def display_details_movies(movie_id):
    movie = df_movies_full[df_movies_full['tconst'] == movie_id]
    if not movie.empty:
        row = movie.iloc[0]
        genre_columns = [col for col in df_movies_full.columns if col.startswith('genres_')]
        genres = [col.split('_')[1] for col in genre_columns if row[col] == 1]
        runtime_minutes = row['runtimeMinutes']
        hours = runtime_minutes // 60
        minutes = runtime_minutes % 60
        runtime_formatted = f"{hours}h{minutes}m" if hours > 0 else f"{minutes}m"

        st.markdown(f"**{row['primaryTitle']}** ({runtime_formatted})")
        st.markdown(f"**Année :** {row['startYear']}")
        st.markdown(f"**Genres :** {', '.join(genres)}")
        st.markdown(f"**Note :** {row['averageRating']}/10")
        st.markdown(f"**Résumé :** {row['overview']}")
        st.markdown("---")

# Afficher les détails d'une série
def display_details_series(serie_id):
    serie = df_series_full[df_series_full['tconst'] == serie_id]
    if not serie.empty:
        row = serie.iloc[0]
        genre_columns = [col for col in df_series_full.columns if col.startswith('genres_')]
        genres = [col.split('_')[1] for col in genre_columns if row[col] == 1]
        runtime_minutes = row['runtimeMinutes']
        hours = runtime_minutes // 60
        minutes = runtime_minutes % 60
        runtime_formatted = f"{hours}h{minutes}m" if hours > 0 else f"{minutes}m"

        st.markdown(f"**{row['primaryTitle']}** ({runtime_formatted})")
        st.markdown(f"**Année :** {row['startYear']}")
        st.markdown(f"**Genres :** {', '.join(genres)}")
        st.markdown(f"**Note :** {row['averageRating']}/10")
        st.markdown(f"**Résumé:** {row['overview']}")
        if 'seasonNumber' in df_series_full.columns and 'episodeNumber' in df_series_full.columns:
            total_seasons = row['seasonNumber']
            total_episodes = row['episodeNumber']
            st.markdown(f"**Saison :** {total_seasons}")
            st.markdown(f"**Episode :** {total_episodes}")
        st.markdown("---")

# Streamlit App
st.image('./header.png')
# st.title("Recommandations de films et de série")

# Demander à l'utilisateur s'il souhaite une recommandation pour un film ou une série
option = st.radio("Voulez-vous une recommandation pour un film ou une série ?", ('Film', 'Série'))

if option == 'Film':
    movie_options = df_movies_full['primaryTitle'].tolist()
    movie_title = st.selectbox("Choisissez un film ou saisissez le nom d'un film :", movie_options)

    if st.button('Obtenir des recommandations de films'):
        selected_movie, recommended_movies = recommend_movies(movie_title, df_movies_full, X_movies_scaled, knn_movies, 5)
        if recommended_movies:
            st.markdown(f"### Recommandations pour : {selected_movie}")
            for movie_id in recommended_movies:
                poster_path = get_poster_path(df_movies_full, movie_id)
                col1, col2 = st.columns([1, 3])
                with col1:
                    st.image(poster_path)
                with col2:
                    display_details_movies(movie_id)
        else:
            st.markdown("Aucune recommandation trouvée.")

elif option == 'Série':
    serie_options = df_series_full['primaryTitle'].tolist()
    serie_title = st.selectbox("Choisissez une série ou saisissez le nom d'une série :", serie_options)

    if st.button('Obtenir des recommandations de séries'):
        selected_serie, recommended_series = recommend_series(serie_title, df_series_full, X_series_scaled, knn_series, 5)
        if recommended_series:
            st.markdown(f"### Recommandations pour : {selected_serie}")
            for serie_id in recommended_series:
                poster_path = get_poster_path(df_series_full, serie_id)
                col1, col2 = st.columns([1, 3])
                with col1:
                    st.image(poster_path)
                with col2:
                    display_details_series(serie_id)
        else:
            st.markdown("Aucune recommandation trouvée.")